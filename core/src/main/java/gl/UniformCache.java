package gl;

import lombok.AllArgsConstructor;
import org.apache.http.util.Asserts;
import org.lwjgl.opengl.GL46;
import org.lwjgl.system.MemoryUtil;

import javax.annotation.ParametersAreNonnullByDefault;
import java.io.Closeable;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.HashMap;

/**
 * the uniform cache class, generated by code
 */
@AllArgsConstructor
@SuppressWarnings({"unused", "resource"})
@ParametersAreNonnullByDefault
public class UniformCache implements Closeable {

	private final IProgram program;

	private int queryLocation(String uniformName) {
		var id = GL46.glGetUniformLocation(this.program.getId(), uniformName);
		Asserts.check(id >= 0, "can't get uniform:" + uniformName + " from program:" + program.getName());
		return id;
	}

	private final HashMap<String, UniformInt1Entry> uniformInt1Map = new HashMap<>(1);

	private static class UniformInt1Entry {
		private final int location;

		private UniformInt1Entry(int location) {
			this.location = location;
		}

		private int x;

		private void tryUpdate(int programId, int x) {
			if (this.x != x) {
				this.x = x;
				GL46.glProgramUniform1i(programId, this.location, x);
			}
		}

	}

	public void uniformInt1(String uniformName, int x) {
		uniformInt1Map.computeIfAbsent(uniformName, name -> new UniformInt1Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x);
	}

	private final HashMap<String, UniformInt1ArrayEntry> uniformInt1ArrayMap = new HashMap<>(1);

	private static class UniformInt1ArrayEntry {
		private final int location;

		private UniformInt1ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[1];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				GL46.glProgramUniform1iv(programId, this.location, array);
			}
		}

	}

	public void uniformInt1Array(String uniformName, int[] array) {
		uniformInt1ArrayMap.computeIfAbsent(uniformName, name -> new UniformInt1ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformInt1BufferEntry> uniformInt1BufferMap = new HashMap<>(1);

	private static class UniformInt1BufferEntry implements Closeable {
		private final int location;

		private UniformInt1BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(1);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform1iv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformInt1Buffer(String uniformName, IntBuffer buffer) {
		uniformInt1BufferMap.computeIfAbsent(uniformName, name -> new UniformInt1BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformFloat1Entry> uniformFloat1Map = new HashMap<>(1);

	private static class UniformFloat1Entry {
		private final int location;

		private UniformFloat1Entry(int location) {
			this.location = location;
		}

		private float x;

		private void tryUpdate(int programId, float x) {
			if (this.x != x) {
				this.x = x;
				GL46.glProgramUniform1f(programId, this.location, x);
			}
		}

	}

	public void uniformFloat1(String uniformName, float x) {
		uniformFloat1Map.computeIfAbsent(uniformName, name -> new UniformFloat1Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x);
	}

	private final HashMap<String, UniformFloat1BufferEntry> uniformFloat1BufferMap = new HashMap<>(1);

	private static class UniformFloat1BufferEntry implements Closeable {
		private final int location;

		private UniformFloat1BufferEntry(int location) {
			this.location = location;
		}

		private final FloatBuffer buffer = MemoryUtil.memAllocFloat(1);

		private void tryUpdate(int programId, FloatBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform1fv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformFloat1Buffer(String uniformName, FloatBuffer buffer) {
		uniformFloat1BufferMap.computeIfAbsent(uniformName, name -> new UniformFloat1BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformFloat1ArrayEntry> uniformFloat1ArrayMap = new HashMap<>(1);

	private static class UniformFloat1ArrayEntry {
		private final int location;

		private UniformFloat1ArrayEntry(int location) {
			this.location = location;
		}

		private final float[] array = new float[1];

		private void tryUpdate(int programId, float[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				GL46.glProgramUniform1fv(programId, this.location, array);
			}
		}

	}

	public void uniformFloat1Array(String uniformName, float[] array) {
		uniformFloat1ArrayMap.computeIfAbsent(uniformName, name -> new UniformFloat1ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformDouble1Entry> uniformDouble1Map = new HashMap<>(1);

	private static class UniformDouble1Entry {
		private final int location;

		private UniformDouble1Entry(int location) {
			this.location = location;
		}

		private double x;

		private void tryUpdate(int programId, double x) {
			if (this.x != x) {
				this.x = x;
				GL46.glProgramUniform1d(programId, this.location, x);
			}
		}

	}

	public void uniformDouble1(String uniformName, double x) {
		uniformDouble1Map.computeIfAbsent(uniformName, name -> new UniformDouble1Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x);
	}

	private final HashMap<String, UniformDouble1ArrayEntry> uniformDouble1ArrayMap = new HashMap<>(1);

	private static class UniformDouble1ArrayEntry {
		private final int location;

		private UniformDouble1ArrayEntry(int location) {
			this.location = location;
		}

		private final double[] array = new double[1];

		private void tryUpdate(int programId, double[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				GL46.glProgramUniform1dv(programId, this.location, array);
			}
		}

	}

	public void uniformDouble1Array(String uniformName, double[] array) {
		uniformDouble1ArrayMap.computeIfAbsent(uniformName, name -> new UniformDouble1ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformDouble1BufferEntry> uniformDouble1BufferMap = new HashMap<>(1);

	private static class UniformDouble1BufferEntry implements Closeable {
		private final int location;

		private UniformDouble1BufferEntry(int location) {
			this.location = location;
		}

		private final DoubleBuffer buffer = MemoryUtil.memAllocDouble(1);

		private void tryUpdate(int programId, DoubleBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform1dv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformDouble1Buffer(String uniformName, DoubleBuffer buffer) {
		uniformDouble1BufferMap.computeIfAbsent(uniformName, name -> new UniformDouble1BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformUInt1BufferEntry> uniformUInt1BufferMap = new HashMap<>(1);

	private static class UniformUInt1BufferEntry implements Closeable {
		private final int location;

		private UniformUInt1BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(1);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform1uiv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformUInt1Buffer(String uniformName, IntBuffer buffer) {
		uniformUInt1BufferMap.computeIfAbsent(uniformName, name -> new UniformUInt1BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformUInt1ArrayEntry> uniformUInt1ArrayMap = new HashMap<>(1);

	private static class UniformUInt1ArrayEntry {
		private final int location;

		private UniformUInt1ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[1];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				GL46.glProgramUniform1uiv(programId, this.location, array);
			}
		}

	}

	public void uniformUInt1Array(String uniformName, int[] array) {
		uniformUInt1ArrayMap.computeIfAbsent(uniformName, name -> new UniformUInt1ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformUInt1Entry> uniformUInt1Map = new HashMap<>(1);

	private static class UniformUInt1Entry {
		private final int location;

		private UniformUInt1Entry(int location) {
			this.location = location;
		}

		private int x;

		private void tryUpdate(int programId, int x) {
			if (this.x != x) {
				this.x = x;
				GL46.glProgramUniform1ui(programId, this.location, x);
			}
		}

	}

	public void uniformUInt1(String uniformName, int x) {
		uniformUInt1Map.computeIfAbsent(uniformName, name -> new UniformUInt1Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x);
	}

	private final HashMap<String, UniformInt2Entry> uniformInt2Map = new HashMap<>(1);

	private static class UniformInt2Entry {
		private final int location;

		private UniformInt2Entry(int location) {
			this.location = location;
		}

		private int x;
		private int y;

		private void tryUpdate(int programId, int x, int y) {
			if (this.x != x || this.y != y) {
				this.x = x;
				this.y = y;
				GL46.glProgramUniform2i(programId, this.location, x, y);
			}
		}

	}

	public void uniformInt2(String uniformName, int x, int y) {
		uniformInt2Map.computeIfAbsent(uniformName, name -> new UniformInt2Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y);
	}

	private final HashMap<String, UniformInt2ArrayEntry> uniformInt2ArrayMap = new HashMap<>(1);

	private static class UniformInt2ArrayEntry {
		private final int location;

		private UniformInt2ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[2];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				GL46.glProgramUniform2iv(programId, this.location, array);
			}
		}

	}

	public void uniformInt2Array(String uniformName, int[] array) {
		uniformInt2ArrayMap.computeIfAbsent(uniformName, name -> new UniformInt2ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformInt2BufferEntry> uniformInt2BufferMap = new HashMap<>(1);

	private static class UniformInt2BufferEntry implements Closeable {
		private final int location;

		private UniformInt2BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(2);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform2iv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformInt2Buffer(String uniformName, IntBuffer buffer) {
		uniformInt2BufferMap.computeIfAbsent(uniformName, name -> new UniformInt2BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformDouble2Entry> uniformDouble2Map = new HashMap<>(1);

	private static class UniformDouble2Entry {
		private final int location;

		private UniformDouble2Entry(int location) {
			this.location = location;
		}

		private double x;
		private double y;

		private void tryUpdate(int programId, double x, double y) {
			if (this.x != x || this.y != y) {
				this.x = x;
				this.y = y;
				GL46.glProgramUniform2d(programId, this.location, x, y);
			}
		}

	}

	public void uniformDouble2(String uniformName, double x, double y) {
		uniformDouble2Map.computeIfAbsent(uniformName, name -> new UniformDouble2Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y);
	}

	private final HashMap<String, UniformDouble2BufferEntry> uniformDouble2BufferMap = new HashMap<>(1);

	private static class UniformDouble2BufferEntry implements Closeable {
		private final int location;

		private UniformDouble2BufferEntry(int location) {
			this.location = location;
		}

		private final DoubleBuffer buffer = MemoryUtil.memAllocDouble(2);

		private void tryUpdate(int programId, DoubleBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform2dv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformDouble2Buffer(String uniformName, DoubleBuffer buffer) {
		uniformDouble2BufferMap.computeIfAbsent(uniformName, name -> new UniformDouble2BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformDouble2ArrayEntry> uniformDouble2ArrayMap = new HashMap<>(1);

	private static class UniformDouble2ArrayEntry {
		private final int location;

		private UniformDouble2ArrayEntry(int location) {
			this.location = location;
		}

		private final double[] array = new double[2];

		private void tryUpdate(int programId, double[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				GL46.glProgramUniform2dv(programId, this.location, array);
			}
		}

	}

	public void uniformDouble2Array(String uniformName, double[] array) {
		uniformDouble2ArrayMap.computeIfAbsent(uniformName, name -> new UniformDouble2ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformFloat2Entry> uniformFloat2Map = new HashMap<>(1);

	private static class UniformFloat2Entry {
		private final int location;

		private UniformFloat2Entry(int location) {
			this.location = location;
		}

		private float x;
		private float y;

		private void tryUpdate(int programId, float x, float y) {
			if (this.x != x || this.y != y) {
				this.x = x;
				this.y = y;
				GL46.glProgramUniform2f(programId, this.location, x, y);
			}
		}

	}

	public void uniformFloat2(String uniformName, float x, float y) {
		uniformFloat2Map.computeIfAbsent(uniformName, name -> new UniformFloat2Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y);
	}

	private final HashMap<String, UniformFloat2BufferEntry> uniformFloat2BufferMap = new HashMap<>(1);

	private static class UniformFloat2BufferEntry implements Closeable {
		private final int location;

		private UniformFloat2BufferEntry(int location) {
			this.location = location;
		}

		private final FloatBuffer buffer = MemoryUtil.memAllocFloat(2);

		private void tryUpdate(int programId, FloatBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform2fv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformFloat2Buffer(String uniformName, FloatBuffer buffer) {
		uniformFloat2BufferMap.computeIfAbsent(uniformName, name -> new UniformFloat2BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformFloat2ArrayEntry> uniformFloat2ArrayMap = new HashMap<>(1);

	private static class UniformFloat2ArrayEntry {
		private final int location;

		private UniformFloat2ArrayEntry(int location) {
			this.location = location;
		}

		private final float[] array = new float[2];

		private void tryUpdate(int programId, float[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				GL46.glProgramUniform2fv(programId, this.location, array);
			}
		}

	}

	public void uniformFloat2Array(String uniformName, float[] array) {
		uniformFloat2ArrayMap.computeIfAbsent(uniformName, name -> new UniformFloat2ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformUInt2BufferEntry> uniformUInt2BufferMap = new HashMap<>(1);

	private static class UniformUInt2BufferEntry implements Closeable {
		private final int location;

		private UniformUInt2BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(2);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform2uiv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformUInt2Buffer(String uniformName, IntBuffer buffer) {
		uniformUInt2BufferMap.computeIfAbsent(uniformName, name -> new UniformUInt2BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformUInt2ArrayEntry> uniformUInt2ArrayMap = new HashMap<>(1);

	private static class UniformUInt2ArrayEntry {
		private final int location;

		private UniformUInt2ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[2];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				GL46.glProgramUniform2uiv(programId, this.location, array);
			}
		}

	}

	public void uniformUInt2Array(String uniformName, int[] array) {
		uniformUInt2ArrayMap.computeIfAbsent(uniformName, name -> new UniformUInt2ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformUInt2Entry> uniformUInt2Map = new HashMap<>(1);

	private static class UniformUInt2Entry {
		private final int location;

		private UniformUInt2Entry(int location) {
			this.location = location;
		}

		private int x;
		private int y;

		private void tryUpdate(int programId, int x, int y) {
			if (this.x != x || this.y != y) {
				this.x = x;
				this.y = y;
				GL46.glProgramUniform2ui(programId, this.location, x, y);
			}
		}

	}

	public void uniformUInt2(String uniformName, int x, int y) {
		uniformUInt2Map.computeIfAbsent(uniformName, name -> new UniformUInt2Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y);
	}

	private final HashMap<String, UniformFloat3Entry> uniformFloat3Map = new HashMap<>(1);

	private static class UniformFloat3Entry {
		private final int location;

		private UniformFloat3Entry(int location) {
			this.location = location;
		}

		private float x;
		private float y;
		private float z;

		private void tryUpdate(int programId, float x, float y, float z) {
			if (this.x != x || this.y != y || this.z != z) {
				this.x = x;
				this.y = y;
				this.z = z;
				GL46.glProgramUniform3f(programId, this.location, x, y, z);
			}
		}

	}

	public void uniformFloat3(String uniformName, float x, float y, float z) {
		uniformFloat3Map.computeIfAbsent(uniformName, name -> new UniformFloat3Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z);
	}

	private final HashMap<String, UniformFloat3ArrayEntry> uniformFloat3ArrayMap = new HashMap<>(1);

	private static class UniformFloat3ArrayEntry {
		private final int location;

		private UniformFloat3ArrayEntry(int location) {
			this.location = location;
		}

		private final float[] array = new float[3];

		private void tryUpdate(int programId, float[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				GL46.glProgramUniform3fv(programId, this.location, array);
			}
		}

	}

	public void uniformFloat3Array(String uniformName, float[] array) {
		uniformFloat3ArrayMap.computeIfAbsent(uniformName, name -> new UniformFloat3ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformFloat3BufferEntry> uniformFloat3BufferMap = new HashMap<>(1);

	private static class UniformFloat3BufferEntry implements Closeable {
		private final int location;

		private UniformFloat3BufferEntry(int location) {
			this.location = location;
		}

		private final FloatBuffer buffer = MemoryUtil.memAllocFloat(3);

		private void tryUpdate(int programId, FloatBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform3fv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformFloat3Buffer(String uniformName, FloatBuffer buffer) {
		uniformFloat3BufferMap.computeIfAbsent(uniformName, name -> new UniformFloat3BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformDouble3Entry> uniformDouble3Map = new HashMap<>(1);

	private static class UniformDouble3Entry {
		private final int location;

		private UniformDouble3Entry(int location) {
			this.location = location;
		}

		private double x;
		private double y;
		private double z;

		private void tryUpdate(int programId, double x, double y, double z) {
			if (this.x != x || this.y != y || this.z != z) {
				this.x = x;
				this.y = y;
				this.z = z;
				GL46.glProgramUniform3d(programId, this.location, x, y, z);
			}
		}

	}

	public void uniformDouble3(String uniformName, double x, double y, double z) {
		uniformDouble3Map.computeIfAbsent(uniformName, name -> new UniformDouble3Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z);
	}

	private final HashMap<String, UniformDouble3ArrayEntry> uniformDouble3ArrayMap = new HashMap<>(1);

	private static class UniformDouble3ArrayEntry {
		private final int location;

		private UniformDouble3ArrayEntry(int location) {
			this.location = location;
		}

		private final double[] array = new double[3];

		private void tryUpdate(int programId, double[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				GL46.glProgramUniform3dv(programId, this.location, array);
			}
		}

	}

	public void uniformDouble3Array(String uniformName, double[] array) {
		uniformDouble3ArrayMap.computeIfAbsent(uniformName, name -> new UniformDouble3ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformDouble3BufferEntry> uniformDouble3BufferMap = new HashMap<>(1);

	private static class UniformDouble3BufferEntry implements Closeable {
		private final int location;

		private UniformDouble3BufferEntry(int location) {
			this.location = location;
		}

		private final DoubleBuffer buffer = MemoryUtil.memAllocDouble(3);

		private void tryUpdate(int programId, DoubleBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform3dv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformDouble3Buffer(String uniformName, DoubleBuffer buffer) {
		uniformDouble3BufferMap.computeIfAbsent(uniformName, name -> new UniformDouble3BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformInt3Entry> uniformInt3Map = new HashMap<>(1);

	private static class UniformInt3Entry {
		private final int location;

		private UniformInt3Entry(int location) {
			this.location = location;
		}

		private int x;
		private int y;
		private int z;

		private void tryUpdate(int programId, int x, int y, int z) {
			if (this.x != x || this.y != y || this.z != z) {
				this.x = x;
				this.y = y;
				this.z = z;
				GL46.glProgramUniform3i(programId, this.location, x, y, z);
			}
		}

	}

	public void uniformInt3(String uniformName, int x, int y, int z) {
		uniformInt3Map.computeIfAbsent(uniformName, name -> new UniformInt3Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z);
	}

	private final HashMap<String, UniformInt3BufferEntry> uniformInt3BufferMap = new HashMap<>(1);

	private static class UniformInt3BufferEntry implements Closeable {
		private final int location;

		private UniformInt3BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(3);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform3iv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformInt3Buffer(String uniformName, IntBuffer buffer) {
		uniformInt3BufferMap.computeIfAbsent(uniformName, name -> new UniformInt3BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformInt3ArrayEntry> uniformInt3ArrayMap = new HashMap<>(1);

	private static class UniformInt3ArrayEntry {
		private final int location;

		private UniformInt3ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[3];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				GL46.glProgramUniform3iv(programId, this.location, array);
			}
		}

	}

	public void uniformInt3Array(String uniformName, int[] array) {
		uniformInt3ArrayMap.computeIfAbsent(uniformName, name -> new UniformInt3ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformUInt3Entry> uniformUInt3Map = new HashMap<>(1);

	private static class UniformUInt3Entry {
		private final int location;

		private UniformUInt3Entry(int location) {
			this.location = location;
		}

		private int x;
		private int y;
		private int z;

		private void tryUpdate(int programId, int x, int y, int z) {
			if (this.x != x || this.y != y || this.z != z) {
				this.x = x;
				this.y = y;
				this.z = z;
				GL46.glProgramUniform3ui(programId, this.location, x, y, z);
			}
		}

	}

	public void uniformUInt3(String uniformName, int x, int y, int z) {
		uniformUInt3Map.computeIfAbsent(uniformName, name -> new UniformUInt3Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z);
	}

	private final HashMap<String, UniformUInt3BufferEntry> uniformUInt3BufferMap = new HashMap<>(1);

	private static class UniformUInt3BufferEntry implements Closeable {
		private final int location;

		private UniformUInt3BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(3);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform3uiv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformUInt3Buffer(String uniformName, IntBuffer buffer) {
		uniformUInt3BufferMap.computeIfAbsent(uniformName, name -> new UniformUInt3BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformUInt3ArrayEntry> uniformUInt3ArrayMap = new HashMap<>(1);

	private static class UniformUInt3ArrayEntry {
		private final int location;

		private UniformUInt3ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[3];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				GL46.glProgramUniform3uiv(programId, this.location, array);
			}
		}

	}

	public void uniformUInt3Array(String uniformName, int[] array) {
		uniformUInt3ArrayMap.computeIfAbsent(uniformName, name -> new UniformUInt3ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformInt4Entry> uniformInt4Map = new HashMap<>(1);

	private static class UniformInt4Entry {
		private final int location;

		private UniformInt4Entry(int location) {
			this.location = location;
		}

		private int x;
		private int y;
		private int z;
		private int w;

		private void tryUpdate(int programId, int x, int y, int z, int w) {
			if (this.x != x || this.y != y || this.z != z || this.w != w) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
				GL46.glProgramUniform4i(programId, this.location, x, y, z, w);
			}
		}

	}

	public void uniformInt4(String uniformName, int x, int y, int z, int w) {
		uniformInt4Map.computeIfAbsent(uniformName, name -> new UniformInt4Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z, w);
	}

	private final HashMap<String, UniformInt4BufferEntry> uniformInt4BufferMap = new HashMap<>(1);

	private static class UniformInt4BufferEntry implements Closeable {
		private final int location;

		private UniformInt4BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(4);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform4iv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformInt4Buffer(String uniformName, IntBuffer buffer) {
		uniformInt4BufferMap.computeIfAbsent(uniformName, name -> new UniformInt4BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformInt4ArrayEntry> uniformInt4ArrayMap = new HashMap<>(1);

	private static class UniformInt4ArrayEntry {
		private final int location;

		private UniformInt4ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[4];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				this.array[3] = array[3];
				GL46.glProgramUniform4iv(programId, this.location, array);
			}
		}

	}

	public void uniformInt4Array(String uniformName, int[] array) {
		uniformInt4ArrayMap.computeIfAbsent(uniformName, name -> new UniformInt4ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformDouble4Entry> uniformDouble4Map = new HashMap<>(1);

	private static class UniformDouble4Entry {
		private final int location;

		private UniformDouble4Entry(int location) {
			this.location = location;
		}

		private double x;
		private double y;
		private double z;
		private double w;

		private void tryUpdate(int programId, double x, double y, double z, double w) {
			if (this.x != x || this.y != y || this.z != z || this.w != w) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
				GL46.glProgramUniform4d(programId, this.location, x, y, z, w);
			}
		}

	}

	public void uniformDouble4(String uniformName, double x, double y, double z, double w) {
		uniformDouble4Map.computeIfAbsent(uniformName, name -> new UniformDouble4Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z, w);
	}

	private final HashMap<String, UniformDouble4ArrayEntry> uniformDouble4ArrayMap = new HashMap<>(1);

	private static class UniformDouble4ArrayEntry {
		private final int location;

		private UniformDouble4ArrayEntry(int location) {
			this.location = location;
		}

		private final double[] array = new double[4];

		private void tryUpdate(int programId, double[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				this.array[3] = array[3];
				GL46.glProgramUniform4dv(programId, this.location, array);
			}
		}

	}

	public void uniformDouble4Array(String uniformName, double[] array) {
		uniformDouble4ArrayMap.computeIfAbsent(uniformName, name -> new UniformDouble4ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformDouble4BufferEntry> uniformDouble4BufferMap = new HashMap<>(1);

	private static class UniformDouble4BufferEntry implements Closeable {
		private final int location;

		private UniformDouble4BufferEntry(int location) {
			this.location = location;
		}

		private final DoubleBuffer buffer = MemoryUtil.memAllocDouble(4);

		private void tryUpdate(int programId, DoubleBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform4dv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformDouble4Buffer(String uniformName, DoubleBuffer buffer) {
		uniformDouble4BufferMap.computeIfAbsent(uniformName, name -> new UniformDouble4BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformFloat4Entry> uniformFloat4Map = new HashMap<>(1);

	private static class UniformFloat4Entry {
		private final int location;

		private UniformFloat4Entry(int location) {
			this.location = location;
		}

		private float x;
		private float y;
		private float z;
		private float w;

		private void tryUpdate(int programId, float x, float y, float z, float w) {
			if (this.x != x || this.y != y || this.z != z || this.w != w) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
				GL46.glProgramUniform4f(programId, this.location, x, y, z, w);
			}
		}

	}

	public void uniformFloat4(String uniformName, float x, float y, float z, float w) {
		uniformFloat4Map.computeIfAbsent(uniformName, name -> new UniformFloat4Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z, w);
	}

	private final HashMap<String, UniformFloat4ArrayEntry> uniformFloat4ArrayMap = new HashMap<>(1);

	private static class UniformFloat4ArrayEntry {
		private final int location;

		private UniformFloat4ArrayEntry(int location) {
			this.location = location;
		}

		private final float[] array = new float[4];

		private void tryUpdate(int programId, float[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				this.array[3] = array[3];
				GL46.glProgramUniform4fv(programId, this.location, array);
			}
		}

	}

	public void uniformFloat4Array(String uniformName, float[] array) {
		uniformFloat4ArrayMap.computeIfAbsent(uniformName, name -> new UniformFloat4ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformFloat4BufferEntry> uniformFloat4BufferMap = new HashMap<>(1);

	private static class UniformFloat4BufferEntry implements Closeable {
		private final int location;

		private UniformFloat4BufferEntry(int location) {
			this.location = location;
		}

		private final FloatBuffer buffer = MemoryUtil.memAllocFloat(4);

		private void tryUpdate(int programId, FloatBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform4fv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformFloat4Buffer(String uniformName, FloatBuffer buffer) {
		uniformFloat4BufferMap.computeIfAbsent(uniformName, name -> new UniformFloat4BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformUInt4ArrayEntry> uniformUInt4ArrayMap = new HashMap<>(1);

	private static class UniformUInt4ArrayEntry {
		private final int location;

		private UniformUInt4ArrayEntry(int location) {
			this.location = location;
		}

		private final int[] array = new int[4];

		private void tryUpdate(int programId, int[] array) {
			if (!Arrays.equals(this.array, array)) {
				this.array[0] = array[0];
				this.array[1] = array[1];
				this.array[2] = array[2];
				this.array[3] = array[3];
				GL46.glProgramUniform4uiv(programId, this.location, array);
			}
		}

	}

	public void uniformUInt4Array(String uniformName, int[] array) {
		uniformUInt4ArrayMap.computeIfAbsent(uniformName, name -> new UniformUInt4ArrayEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), array);
	}

	private final HashMap<String, UniformUInt4BufferEntry> uniformUInt4BufferMap = new HashMap<>(1);

	private static class UniformUInt4BufferEntry implements Closeable {
		private final int location;

		private UniformUInt4BufferEntry(int location) {
			this.location = location;
		}

		private final IntBuffer buffer = MemoryUtil.memAllocInt(4);

		private void tryUpdate(int programId, IntBuffer buffer) {
			if (!this.buffer.equals(buffer)) {
				while (buffer.hasRemaining()) {
					this.buffer.put(buffer.get());
				}
				this.buffer.flip();
				buffer.flip();
				GL46.glProgramUniform4uiv(programId, this.location, buffer);
			}
		}

		@Override
		public void close() {
			MemoryUtil.memFree(this.buffer);
		}
	}

	public void uniformUInt4Buffer(String uniformName, IntBuffer buffer) {
		uniformUInt4BufferMap.computeIfAbsent(uniformName, name -> new UniformUInt4BufferEntry(queryLocation(name)))
				.tryUpdate(this.program.getId(), buffer);
	}

	private final HashMap<String, UniformUInt4Entry> uniformUInt4Map = new HashMap<>(1);

	private static class UniformUInt4Entry {
		private final int location;

		private UniformUInt4Entry(int location) {
			this.location = location;
		}

		private int x;
		private int y;
		private int z;
		private int w;

		private void tryUpdate(int programId, int x, int y, int z, int w) {
			if (this.x != x || this.y != y || this.z != z || this.w != w) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
				GL46.glProgramUniform4ui(programId, this.location, x, y, z, w);
			}
		}

	}

	public void uniformUInt4(String uniformName, int x, int y, int z, int w) {
		uniformUInt4Map.computeIfAbsent(uniformName, name -> new UniformUInt4Entry(queryLocation(name)))
				.tryUpdate(this.program.getId(), x, y, z, w);
	}

	@Override
	public void close() {
		uniformInt1BufferMap.forEach((k, v) -> v.close());
		uniformFloat1BufferMap.forEach((k, v) -> v.close());
		uniformDouble1BufferMap.forEach((k, v) -> v.close());
		uniformUInt1BufferMap.forEach((k, v) -> v.close());
		uniformInt2BufferMap.forEach((k, v) -> v.close());
		uniformDouble2BufferMap.forEach((k, v) -> v.close());
		uniformFloat2BufferMap.forEach((k, v) -> v.close());
		uniformUInt2BufferMap.forEach((k, v) -> v.close());
		uniformFloat3BufferMap.forEach((k, v) -> v.close());
		uniformDouble3BufferMap.forEach((k, v) -> v.close());
		uniformInt3BufferMap.forEach((k, v) -> v.close());
		uniformUInt3BufferMap.forEach((k, v) -> v.close());
		uniformInt4BufferMap.forEach((k, v) -> v.close());
		uniformDouble4BufferMap.forEach((k, v) -> v.close());
		uniformFloat4BufferMap.forEach((k, v) -> v.close());
		uniformUInt4BufferMap.forEach((k, v) -> v.close());

		uniformInt1Map.clear();
		uniformInt1ArrayMap.clear();
		uniformInt1BufferMap.clear();
		uniformFloat1Map.clear();
		uniformFloat1BufferMap.clear();
		uniformFloat1ArrayMap.clear();
		uniformDouble1Map.clear();
		uniformDouble1ArrayMap.clear();
		uniformDouble1BufferMap.clear();
		uniformUInt1BufferMap.clear();
		uniformUInt1ArrayMap.clear();
		uniformUInt1Map.clear();
		uniformInt2Map.clear();
		uniformInt2ArrayMap.clear();
		uniformInt2BufferMap.clear();
		uniformDouble2Map.clear();
		uniformDouble2BufferMap.clear();
		uniformDouble2ArrayMap.clear();
		uniformFloat2Map.clear();
		uniformFloat2BufferMap.clear();
		uniformFloat2ArrayMap.clear();
		uniformUInt2BufferMap.clear();
		uniformUInt2ArrayMap.clear();
		uniformUInt2Map.clear();
		uniformFloat3Map.clear();
		uniformFloat3ArrayMap.clear();
		uniformFloat3BufferMap.clear();
		uniformDouble3Map.clear();
		uniformDouble3ArrayMap.clear();
		uniformDouble3BufferMap.clear();
		uniformInt3Map.clear();
		uniformInt3BufferMap.clear();
		uniformInt3ArrayMap.clear();
		uniformUInt3Map.clear();
		uniformUInt3BufferMap.clear();
		uniformUInt3ArrayMap.clear();
		uniformInt4Map.clear();
		uniformInt4BufferMap.clear();
		uniformInt4ArrayMap.clear();
		uniformDouble4Map.clear();
		uniformDouble4ArrayMap.clear();
		uniformDouble4BufferMap.clear();
		uniformFloat4Map.clear();
		uniformFloat4ArrayMap.clear();
		uniformFloat4BufferMap.clear();
		uniformUInt4ArrayMap.clear();
		uniformUInt4BufferMap.clear();
		uniformUInt4Map.clear();

	}
}
